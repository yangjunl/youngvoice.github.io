---
title: the mechanism of linux signal
description: what happended when you press CTRL-C?
categories: [cs, linux, signal]
tags: [cs, linux, signal]
---
# What is signal? and What is it used to do?
Signals are software interrupts. Signals provide a way of handling asynchronous events(for process).（这个地方是不是需要修正一下，通过下面的知识，可以看出来，信号可以处理 同步事件和异步事件）(补充：这的里 asynchronous 应该是与程序的正常执行控制流程（plan）异步的意思)

The occurrence of a signal may be synchronous or asynchronous to the process or thread, depending on the source of the signal and underlying reason or cause. 

Synchronous signals occur as a direct result of the executing instruction stream, where an unrecoverable error requires an immediate termination of the process. Such sinals are directed to the thread which caused the error with its execution stream. As an error of this type causes a trap into a kernel trap handler, synchronous signals are sometimes referred to as traps.

Asynchronous signals are external to the current execution context. Asynchronous signals are also aptly referred to as interrupts. It can be produced by sending from another process or thread via a kill(2), _lwp_kill(2), sigsend(2) system call, or a thr_kill(3), pthread_kill(3), sigqueue(3) library invocation. It can also be produced by interrupt handler in kernel code.

### 特别注意，信号和硬件上的异常中断的区别和联系
当硬件上收到异常或中断时，内核中的处理程序可以选择给一些进程或线程发送信号
>> If you are familiar with interrupts, signals are very similar in their behavior. The difference is that while interrupts are sent to the operating system by the hardware, signals are sent to the process by the operating system, or by other processes. Note that signals have nothing to do with software interrupts, which are still sent by the hardware.(software interrupts is sent by the cpu itself, in this case)


<http://www.cs.kent.edu/~ruttan/sysprog/lectures/signals.html#masking>


Note:

**interrupts are sent to the operating system by the hardware, signals are sent to the process by the operating system, or by other processes.**
# How can we produce a signal and call our own function to handle it?
## (1)What signal exist? and How to produce a signal?
The most common way of producing a signal is uing the keyboard. There are certain key presses that are interpreted by the system(TTY) as requests to send signals to the process with which we are interacting(前台进程).
e.g
produce a SIGINT to interrupt a process by key CTRL-C
### What signal can system support?
To use command "kill -l" list the system support signals.
### What condition can produce signal?
* 用户在终端按下组合键时，终端驱动程序会发送信号给前台进程，例如终端作业控制中常常使用的("CTRL-C,CTRL-Z,CTRL-\\")分别产生(SIGINT,SIGSTOP,SIGQUIT)
generated by a keyboard entry from the controlling terminal
* sending signals by the command(usually internal to the shell) kill fg(SIGCONT)(SIGSTOP 与 SIGCONT为一对相反的信号)
* sending signals using system call, 通过调用kill函数，从一个进程向另一个进程发送信号
* 硬件异常，譬如，（1）当进程执行了除0操作，内核收到运算单元产生的异常后将会发送SIGFPE信号给进程，（2）当前进程访问非法内存地址，内核收到mmu产生的异常后将发送SIGSEGV信号给进程。

* 内核检测到某种条件，譬如，闹钟超时产生SIGALRM信号，向读端已经关闭的管道写数据时产生SIGPIPE信号。

## (2) How to handle a signal through our own function?
call sigaction(2) to register handler for a signal

## example
```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
void sig_handler(int num)
{
    printf("Here is the %dth signal\n");
}
int global = 0;
int main()
{
    signal(SIGINT, sig_handler);
    while (1) {
        printf("waiting for signal\n");
        sleep(5);
    }
}
```

Ref:
https://devopedia.org/linux-signals


---
# What relationship is needed between the process sending signal and the process receiving signal???
从一个进程调用 kill 系统调用是不可以随意给别的进程发送信号的，至少发送进程需要权限，否则会发送失败。

1. 有CAP_KILL 权限的进程能够给任何进程发送信号。
2. 发送进程的有效或真正的用户 ID 必须等于接收进程的真正或保存的用户 ID

如果signo 是 0， 调用不会发送信号，但是会进程错误检查，这可以用来测试一个进程是否有权限给另一个进程发送信号。

# 如何给特定进程组发送信号，以及发送时的权限要求？？？
killpg(pgrp, signo) 等价于 kill(-pgrp, signo)

# How to protect a critical region of code from a specific signal? (如何安全的在信号处理程序和进程的其他部分共享数据？？)
由于信号处理程序是异步执行，所以信号处理程序不能对进程被中断时的操作有任何假设。
可以暂时阻止接收信号(Masking signals)




## critical region（此处的情况与下面有点像）
这个地方的 临界区 要求有点特殊，要求从 临界区 出来之后等待一个信号的发生，也就是当我们做完临界区的工作之后要等一个事件的发生（实际上，一般情况我们从临界区出来后不会再关注共享资源的那个信号什么时候发生）（we want to unblock a signal and then pause, waiting for the previously blocked signal to occur？）
```c

int main()
{
    sigemptyset(&zeromask);
    sigemptyset(&newmask);
    sigaddset(&newmask, SIGINT);
    sigprocmask(SIG_BLOCK, &newmask, &oldmask);

    /*
    *  Critical region of code
    */

    sigsuspend(&zeromask):

    sigprocmask(SIG_SETMASK, &oldmask, NULL);
    return 0;
}


```
## wait a condition(等某个事件发生)
下面的信号处理函数可以处理多个信号，所以综合起来看，这里的场景与上面的差不多
```c
static void
sig_int(int signo)      /* one signal handler for SIGQUIT */
{
        if (signo == SIGQUIT)
                quitflag = 1;   /* set flag for main loop */
}


int main()
{
    sigemptyset(&zeromask);
    sigemptyset(&newmask);
    sigaddset(&newmask, SIGQUIT);

    sigprocmask(SIG_BLOCK, &newmask, &oldmask);

    while (quitflag == 0)
        sigsuspend(&zeromask);
    quitflag = 0;
    sigprocmask(SIG_SETMASK, &oldmask, NULL);

    return 0;
}

```

# How to implement sleep() using alarm() ???
# 如何避免正在执行信号处理函数时，又收到信号处理请求？？（可能是相同类型的信号，也可能是不同类型的信号）
Masking signals


# 在程序正在执行一个不可重入函数时，信号发生并调用相同的函数，会发生什么情况？？？
1. 进程正在写文件或申请内存，信号处理程序也向同一个文件写入或也在调用 malloc 申请内存会怎么样？
2. 进程正在调用一个使用静态缓存的函数，例如 strsignal()，此时信号发生，会是什么情况？

# What difference exists between thread-safe and async-signal safe???
# What is the meaning of that SIGKILL and SIGSTOP 's default dispositions cannot be changed???
对信号 SIGKILL 和 SIGSTOP 而言，在应用上有什么特别之处？
it is meaning that these signals are non-catchable

# signal 和多线程的关系？
线程拥有私有的 sigmask， 但是当创建线程时，可以通过给 clone 传 CLONE_SIGHAND 来让属于同一个进程的线程共享 current->sig

# 在多线程的环境下，signal 是如何 delivered???
信号的deliver是线程私有的，Asynchronous signals are delivered to the first thread found not blocking the signal. Synchronous signals happening in the context of a given thread are delivered to that thread.

# What the signal generating and signal delivering does perspective???
There is a brief period of time between the time a signal is generated and the time a signal is delivered.

# What is the difference between pending signals and masking signals???
the signal mask of a process is the set of signals currently blocked from delivery to that process.
the sigpending function returns the set of signals that are blocked from delivery.
# Can we have more than one signal pending for a process?
to tell the system "prevent the following signals from interrupting me, but remember if they do occur"

Yes, many standard signals can be pending for a process. However, only one instance of a given signal type can be pending. This is because pending and blocking of signals are implemented as bitmasks, with one bit for signal type.


# How restart a read operation that is interrupted by a signal?
interrupt system call (also ref select and poll)
进程收到信号后，打断想read，write这样的系统调用，还需要考虑，被打断的系统调用是否会重启
```c
again:
    if ((n = read(fd, buf, BUFFSIZE)) < 0) {
        if (errno == EINTR)
            goto again;
        /* handle other errors */
    }
```

# reentrant function (errno)
there is only one errno per thread, and we might potentially modify it. Therefore, as a general rule, when calling async-signal safe function, we should save and restore errno, because the called async-signal safe funcion may change errno.
# reliable and unreliable signals
signal
sigaction


# 可重入与信号处理程序中调用 printf 的问题？？

# 给信号处理程序传递的参数中有一个收到的信号值，这样有什么好处？？？
一个信号处理程序可以处理多个信号

# 在调试或演示代码中，当主程序设置完信号处理程序后，接着运行什么？？
有几种选择，
1. 循环调用pause()
the pause() system call causes the process to halt execution, until a signal is received. It is surely better than a "busy wait" infinite loop. 
2. 循环调用sleep()
3. 直接循环（busy wait）

# 在 fork 之后，子进程和父进程的信号处理有什么关系？
核心问题在于父进程和子进程是否在共享同一个地址空间，这样的话，按道理在刚完成 fork 后，子进程应该完全继承了与父进程相同的信号语义。
在执行 exec 之后，所有的信号都被设置为默认操作（除非是忽略信号），即所有之前捕获的信号都被重置为默认操作，所有其他信号保持不变，因为 exec 之后，之前注册过的信号处理程序可能都不存在。


A child created via fork(2) inherits a copy of its parent's signal dispositions.  During an execve(2), the dispositions  of  handled  signals are reset to the default; the dispositions of ignored signals are left unchanged. (man sigaction)
# SIGCHLD 与僵尸进程形成以及子进程 exit 之间的关系？？？
# linux 上，后台执行的进程如何处理信号 SIGINT 和 SIGQUIT？
后台执行的进程会将 SIGINT 和 SIGQUIT 的处理方式设置为 SIG_IGN


## 这里的处理方式，需要在执行 后台进程 的shell代码中确认一下？？？？
# strsignal 与线程安全？？？
## How to map between signal numbers and names?

# Scenarios
## How we can achieve to unblock a signal and then pause, waiting for the previously blocked signal to occur? 
Before enter critical region we block a signal to prevent the signal interrupting. After executing the critical region, we want unblock the signal and then pause, waiting for the signal to wake up(how ensure not to lost any the signal, otherwise, there is possibility that the thread wait forever), and then continue execute.


the method is to use function sigsuspend.
## pause and wait
let process to sleep and wait for signal to wake up 
## 当程序收到信号需要退出时，可以在信号处理程序中删除程序创建的临时文件
# pause 系统调用的实现？
pause() 系统调用，它可以使进程睡眠，直到进程收到处理或终止进程的信号。
```c
SYSCALL_DEFINE0(pause)
{
	while (!signal_pending(current)) {
		__set_current_state(TASK_INTERRUPTIBLE);
		schedule();
	}
	return -ERESTARTNOHAND;
}
```
pause 只在接收到可捕获的信号时返回，并且在这种情况下该信号被处理（如果该信号被设置为被忽略，则进程不会被唤醒），pause() 系统调用返回 -1， 并将 errno 设置为 EINTR。


# pause 是如何做到只在接收到可捕获信号时返回的？？？
因为 pause 系统调用只执行两个操作，它首先将进程置为可中断的睡眠状态。然后调用schedule()，切换到别的进程运行。***最重要的是该进程实际上不等待任何事件，在接收到信号前，内核不会唤醒该进程。***

# 由上面的问题可以想到进程状态切换的条件都有哪些？？？






# 与 control terminal 相关的信号是如何实现的（如何产生）？
tty

---

# 内核的支持



# The key data structure and function related to signal
signal sets


# How the kernel support the above mechanism of signal???


# do_signal函数和handle_signal函数都完成了哪些工作？？？（核心机制）
存在哪些信号
信号的产生
注册信号处理函数
（内核对处理函数的记录和调用）（do_signal, handle_signal）

# What the function do_signal does?
do_signal 函数用来传递信号，它也是系统调用即将返回用户空间时对信号的预处理程序



# 怎么样通过 handle_signal 函数来执行信号处理程序？？？
执行用户自定义的处理程序也叫 捕获信号

首先将保存在内核态堆栈上的硬件上下文拷贝到当前进程的用户态堆栈中，当信号处理程序终止时，自动调用 sigreturn 系统调用把这个硬件上下文拷贝回到内核态堆栈中，并恢复用户态堆栈中原来的内容。
# 当有多个被挂起的信号等待被处理时，信号处理的流程是什么样的？？？
在 linux-0.11 中，好像是一次只能处理一个，待确认。。。
在最新版的内核中一次（调用一次do_signal）可以处理多个信号

# Some classical signal produced by keyboard??
CTRL-C  SIGINT
CTRL-\  SIGABRT


下面两个是 non-catchable signal
CTRL-Z  SIGSTOP
kill -9 SIGKILL

上面两个信号究竟是 non-catchable 还是 unblocked?????


# How the alarm is implement?
"kernel/time/itimer.c"
```c
/*
 * For backwards compatibility?  This can be done in libc so Alpha
 * and all newer ports shouldn't need it.
 */
SYSCALL_DEFINE1(alarm, unsigned int, seconds)
{
        return alarm_setitimer(seconds);
}

```

```c
/**
 * alarm_setitimer - set alarm in seconds
 *
 * @seconds:    number of seconds until alarm
 *              0 disables the alarm
 *
 * Returns the remaining time in seconds of a pending timer or 0 when
 * the timer is not active.
 *
 * On 32 bit machines the seconds value is limited to (INT_MAX/2) to avoid
 * negative timeval settings which would cause immediate expiry.
 */
static unsigned int alarm_setitimer(unsigned int seconds)
{
        struct itimerspec64 it_new, it_old;

#if BITS_PER_LONG < 64
        if (seconds > INT_MAX)
                seconds = INT_MAX;
#endif
        it_new.it_value.tv_sec = seconds;
        it_new.it_value.tv_nsec = 0;
        it_new.it_interval.tv_sec = it_new.it_interval.tv_nsec = 0;

        do_setitimer(ITIMER_REAL, &it_new, &it_old);

        /*
         * We can't return 0 if we have an alarm pending ...  And we'd
         * better return too much than too little anyway
         */
        if ((!it_old.it_value.tv_sec && it_old.it_value.tv_nsec) ||
              it_old.it_value.tv_nsec >= (NSEC_PER_SEC / 2))
                it_old.it_value.tv_sec++;

        return it_old.it_value.tv_sec;
}

```

```c
/*
 * Returns true if the timeval is in canonical form
 */
#define timeval_valid(t) \
        (((t)->tv_sec >= 0) && (((unsigned long) (t)->tv_usec) < USEC_PER_SEC))

static int do_setitimer(int which, struct itimerspec64 *value,
                        struct itimerspec64 *ovalue)
{
        struct task_struct *tsk = current;
        struct hrtimer *timer;
        ktime_t expires;

        switch (which) {
        case ITIMER_REAL:
again:
                spin_lock_irq(&tsk->sighand->siglock);
                timer = &tsk->signal->real_timer;
                if (ovalue) {
                        ovalue->it_value = itimer_get_remtime(timer);
                        ovalue->it_interval
                                = ktime_to_timespec64(tsk->signal->it_real_incr);
                }
                /* We are sharing ->siglock with it_real_fn() */
                if (hrtimer_try_to_cancel(timer) < 0) {
                        spin_unlock_irq(&tsk->sighand->siglock);
                        hrtimer_cancel_wait_running(timer);
                        goto again;
                }
                expires = timespec64_to_ktime(value->it_value);
                if (expires != 0) {
                        tsk->signal->it_real_incr =
                                timespec64_to_ktime(value->it_interval);
                        hrtimer_start(timer, expires, HRTIMER_MODE_REL);
                } else
                        tsk->signal->it_real_incr = 0;
                trace_itimer_state(ITIMER_REAL, value, 0);
                spin_unlock_irq(&tsk->sighand->siglock);
                break;
        case ITIMER_VIRTUAL:
                set_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);
                break;
        case ITIMER_PROF:
                set_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);
                break;
        default:
                return -EINVAL;
        }
        return 0;
}


```

"./kernel/fork.c"
```c
static int copy_signal(unsigned long clone_flags, struct task_struct *tsk)
{
        struct signal_struct *sig;

        if (clone_flags & CLONE_THREAD)
                return 0;

        sig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL);
        tsk->signal = sig;
        if (!sig)
                return -ENOMEM;

        sig->nr_threads = 1;
        atomic_set(&sig->live, 1);
        refcount_set(&sig->sigcnt, 1);

        /* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */
        sig->thread_head = (struct list_head)LIST_HEAD_INIT(tsk->thread_node);
        tsk->thread_node = (struct list_head)LIST_HEAD_INIT(sig->thread_head);

        init_waitqueue_head(&sig->wait_chldexit);
        sig->curr_target = tsk;
        init_sigpending(&sig->shared_pending);
        INIT_HLIST_HEAD(&sig->multiprocess);
        seqlock_init(&sig->stats_lock);
        prev_cputime_init(&sig->prev_cputime);
#ifdef CONFIG_POSIX_TIMERS
        INIT_LIST_HEAD(&sig->posix_timers);
        hrtimer_init(&sig->real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
        sig->real_timer.function = it_real_fn;
#endif

        task_lock(current->group_leader);
        memcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);
        task_unlock(current->group_leader);

        posix_cpu_timers_init_group(sig);

        tty_audit_fork(sig);
        sched_autogroup_fork(sig);

        sig->oom_score_adj = current->signal->oom_score_adj;
        sig->oom_score_adj_min = current->signal->oom_score_adj_min;

        mutex_init(&sig->cred_guard_mutex);
        init_rwsem(&sig->exec_update_lock);

        return 0;
}


```



"kernel/time/itimer.c"
```c
/*
 * The timer is automagically restarted, when interval != 0
 */
enum hrtimer_restart it_real_fn(struct hrtimer *timer)
{
        struct signal_struct *sig =
                container_of(timer, struct signal_struct, real_timer);
        struct pid *leader_pid = sig->pids[PIDTYPE_TGID];

        trace_itimer_expire(ITIMER_REAL, leader_pid, 0);
        kill_pid_info(SIGALRM, SEND_SIG_PRIV, leader_pid);

        return HRTIMER_NORESTART;
}

```

"kernel/signal.c"
```c
int kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)
{
        int error = -ESRCH;
        struct task_struct *p;

        for (;;) {
                rcu_read_lock();
                p = pid_task(pid, PIDTYPE_PID);
                if (p)
                        error = group_send_sig_info(sig, info, p, PIDTYPE_TGID);
                rcu_read_unlock();
                if (likely(!p || error != -ESRCH))
                        return error;

                /*
                 * The task was unhashed in between, try again.  If it
                 * is dead, pid_task() will return NULL, if we race with
                 * de_thread() it will find the new leader.
                 */
        }
}


/*
 * send signal info to all the members of a group
 */
int group_send_sig_info(int sig, struct kernel_siginfo *info,
                        struct task_struct *p, enum pid_type type)
{
        int ret;

        rcu_read_lock();
        ret = check_kill_permission(sig, info, p);
        rcu_read_unlock();

        if (!ret && sig)
                ret = do_send_sig_info(sig, info, p, type);

        return ret;
}


int do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,
                        enum pid_type type)
{
        unsigned long flags;
        int ret = -ESRCH;

        if (lock_task_sighand(p, &flags)) {
                ret = send_signal(sig, info, p, type);
                unlock_task_sighand(p, &flags);
        }

        return ret;
}

```
# 如何给自己发送信号？
raise() 不是系统调用，而是wrapper
glibc "./sysdeps/unix/sysv/linux/raise.c"
```c
int
raise (int sig)
{
  /* rt_sigprocmask may fail if:

     1. sigsetsize != sizeof (sigset_t) (EINVAL)
     2. a failure in copy from/to user space (EFAULT)
     3. an invalid 'how' operation (EINVAL)

     The first case is already handle in glibc syscall call by using the arch
     defined _NSIG.  Second case is handled by using a stack allocated mask.
     The last one should be handled by the block/unblock functions.  */

  sigset_t set;
  __libc_signal_block_app (&set);

  INTERNAL_SYSCALL_DECL (err);
  pid_t pid = INTERNAL_SYSCALL (getpid, err, 0);
  pid_t tid = INTERNAL_SYSCALL (gettid, err, 0);

  int ret = INLINE_SYSCALL (tgkill, 3, pid, tid, sig);

  __libc_signal_restore_set (&set);

  return ret;
}
libc_hidden_def (raise)
weak_alias (raise, gsignal)

```

"kernel/signal.c"
```c
/**
 *  sys_tgkill - send signal to one specific thread
 *  @tgid: the thread group ID of the thread
 *  @pid: the PID of the thread
 *  @sig: signal to be sent
 *
 *  This syscall also checks the @tgid and returns -ESRCH even if the PID
 *  exists but it's not belonging to the target process anymore. This
 *  method solves the problem of threads exiting and PIDs getting reused.
 */
SYSCALL_DEFINE3(tgkill, pid_t, tgid, pid_t, pid, int, sig)
{
        /* This is only valid for single tasks */
        if (pid <= 0 || tgid <= 0)
                return -EINVAL;

        return do_tkill(tgid, pid, sig);
}



static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
        struct kernel_siginfo info;

        clear_siginfo(&info);
        info.si_signo = sig;
        info.si_errno = 0;
        info.si_code = SI_TKILL;
        info.si_pid = task_tgid_vnr(current);
        info.si_uid = from_kuid_munged(current_user_ns(), current_uid());

        return do_send_specific(tgid, pid, sig, &info);
}


static int
do_send_specific(pid_t tgid, pid_t pid, int sig, struct kernel_siginfo *info)
{
        struct task_struct *p;
        int error = -ESRCH;

        rcu_read_lock();
        p = find_task_by_vpid(pid);
        if (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {
                error = check_kill_permission(sig, info, p);
                /*
                 * The null signal is a permissions and process existence
                 * probe.  No signal is actually delivered.
                 */
                if (!error && sig) {
                        error = do_send_sig_info(sig, info, p, PIDTYPE_PID);
                        /*
                         * If lock_task_sighand() failed we pretend the task
                         * dies after receiving the signal. The window is tiny,
                         * and the signal is private anyway.
                         */
                        if (unlikely(error == -ESRCH))
                                error = 0;
                }
        }
        rcu_read_unlock();

        return error;
}



int do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,
                        enum pid_type type)
{
        unsigned long flags;
        int ret = -ESRCH;

        if (lock_task_sighand(p, &flags)) {
                ret = send_signal(sig, info, p, type);
                unlock_task_sighand(p, &flags);
        }

        return ret;
}


static int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,
                        enum pid_type type)
{
        /* Should SIGKILL or SIGSTOP be received by a pid namespace init? */
        bool force = false;

        if (info == SEND_SIG_NOINFO) {
                /* Force if sent from an ancestor pid namespace */
                force = !task_pid_nr_ns(current, task_active_pid_ns(t));
        } else if (info == SEND_SIG_PRIV) {
                /* Don't ignore kernel generated signals */
                force = true;
        } else if (has_si_pid_and_uid(info)) {
                /* SIGKILL and SIGSTOP is special or has ids */
                struct user_namespace *t_user_ns;

                rcu_read_lock();
                t_user_ns = task_cred_xxx(t, user_ns);
                if (current_user_ns() != t_user_ns) {
                        kuid_t uid = make_kuid(current_user_ns(), info->si_uid);
                        info->si_uid = from_kuid_munged(t_user_ns, uid);
                }
                rcu_read_unlock();

                /* A kernel generated signal? */
                force = (info->si_code == SI_KERNEL);

                /* From an ancestor pid namespace? */
                if (!task_pid_nr_ns(current, task_active_pid_ns(t))) {
                        info->si_pid = 0;
                        force = true;
                }
        }
        return __send_signal(sig, info, t, type, force);
}



static int __send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,
                        enum pid_type type, bool force)
{
        struct sigpending *pending;
        struct sigqueue *q;
        int override_rlimit;
        int ret = 0, result;

        assert_spin_locked(&t->sighand->siglock);

        result = TRACE_SIGNAL_IGNORED;
        if (!prepare_signal(sig, t, force))
                goto ret;

        pending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;
        /*
         * Short-circuit ignored signals and support queuing
         * exactly one non-rt signal, so that we can get more
         * detailed information about the cause of the signal.
         */
        result = TRACE_SIGNAL_ALREADY_PENDING;
        if (legacy_queue(pending, sig))
                goto ret;

        result = TRACE_SIGNAL_DELIVERED;
        /*
         * Skip useless siginfo allocation for SIGKILL and kernel threads.
         */
        if ((sig == SIGKILL) || (t->flags & PF_KTHREAD))
                goto out_set;

        /*
         * Real-time signals must be queued if sent by sigqueue, or
         * some other real-time mechanism.  It is implementation
         * defined whether kill() does so.  We attempt to do so, on
         * the principle of least surprise, but since kill is not
         * allowed to fail with EAGAIN when low on memory we just
         * make sure at least one signal gets delivered and don't
         * pass on the info struct.
         */
        if (sig < SIGRTMIN)
                override_rlimit = (is_si_special(info) || info->si_code >= 0);
        else
                override_rlimit = 0;

        q = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, 0);

        if (q) {
                list_add_tail(&q->list, &pending->list);
                switch ((unsigned long) info) {
                case (unsigned long) SEND_SIG_NOINFO:
                        clear_siginfo(&q->info);
                        q->info.si_signo = sig;
                        q->info.si_errno = 0;
                        q->info.si_code = SI_USER;
                        q->info.si_pid = task_tgid_nr_ns(current,
                                                        task_active_pid_ns(t));
                        rcu_read_lock();
                        q->info.si_uid =
                                from_kuid_munged(task_cred_xxx(t, user_ns),
                                                 current_uid());
                        rcu_read_unlock();
                        break;
                case (unsigned long) SEND_SIG_PRIV:
                        clear_siginfo(&q->info);
                        q->info.si_signo = sig;
                        q->info.si_errno = 0;
                        q->info.si_code = SI_KERNEL;
                        q->info.si_pid = 0;
                        q->info.si_uid = 0;
                        break;
                default:
                        copy_siginfo(&q->info, info);
                        break;
                }
        } else if (!is_si_special(info) &&
                   sig >= SIGRTMIN && info->si_code != SI_USER) {
                /*
                 * Queue overflow, abort.  We may abort if the
                 * signal was rt and sent by user using something
                 * other than kill().
                 */
                result = TRACE_SIGNAL_OVERFLOW_FAIL;
                ret = -EAGAIN;
                goto ret;
        } else {
                /*
                 * This is a silent loss of information.  We still
                 * send the signal, but the *info bits are lost.
                 */
                result = TRACE_SIGNAL_LOSE_INFO;
        }

out_set:
        signalfd_notify(t, sig);
        sigaddset(&pending->signal, sig);

        /* Let multiprocess signals appear after on-going forks */
        if (type > PIDTYPE_TGID) {
                struct multiprocess_signals *delayed;
                hlist_for_each_entry(delayed, &t->signal->multiprocess, node) {
                        sigset_t *signal = &delayed->signal;
                        /* Can't queue both a stop and a continue signal */
                        if (sig == SIGCONT)
                                sigdelsetmask(signal, SIG_KERNEL_STOP_MASK);
                        else if (sig_kernel_stop(sig))
                                sigdelset(signal, SIGCONT);
                        sigaddset(signal, sig);
                }
        }

        complete_signal(sig, t, type);
ret:
        trace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);
        return ret;
}

```




# Reference
The Linux Signals Handling Model
https://www.linuxjournal.com/article/3985

# keyword
IPC(inter-process communication)
signal model
signal blocking and pending



---




# permission check
 (内核进程的权限检查)

# How to support critical region and masking signal
（内核需要 mask signal）（与中断保护临界区有点像）
（当mask的信号被pending时，如何记录？）

# 内核设置handle时对 SIGKILL and SIGSTOP 的检查

# 内核在多线程环境下的信号分发策略

# 内核对被信号打断的系统调用重启的支持

# 内核对sigaction 和 signal的支持区别在哪？


# 与信号相关的系统调用如何实现


---
# linux signal produce and delivery
## try one simple example
1. to set the signal handler for a program, and run it
```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
void sig_handler(int num)
{
    printf("Here is the %dth signal\n");
}
int global = 0;
int main()
{
    signal(SIGINT, sig_handler);
    while (1) {
        printf("waiting for signal\n");
        sleep(5);
    }
}
```

2. after run this program, one need to press the key CTRL-C to produce signal.
# How many signals can we produce?
To use command "kill -l" list the system support signals.


# Which common scenarios are related to signals?
Core file
SIGTERM 来清理一些程序生成的临时文件
pause()系统调用
alarm signal
typing the interrupt key to stop a program at a terminal
when the process exit, it will send SIGCHLD to parent process
SIGSEGV


```markdown
# 1. to kill()




kernel_siginfo

kill
	kill_something_info()
		kill_proc_info
			kill_pid_info
				group_send_sig_info
					do_send_sig_info
						send_signal
		__kill_pgrp_info
		group_send_sig_info
			do_send_sig_info
				send_signal
	
	
tgkill
	do_tkill
		do_send_specific
			do_send_sig_info
				send_signal






# 2. to alarm

it_real_fn
	kill_pid_info



# 3. to exit
do_exit
	exit_notity
		do_notify_parent
			__send_signal

# 4. tty (CTRL-C)
???????????????????


====> send_signal
(when and how to handle)
```



# how to produce signal?
specific_send_sig_info()
group_send_sig_info()



send_signal
# how to delivery signal?
```text
do_signal
	dequeue_signal() (until no nonblocked pending signals are left in both the private and shared pending signal queues)
		1. ignoring the signal

		2. executing a default action
		    The signals whose default action is “dump” may create a core file in the process working directory
	    3. executing a signal handler
            Handle_signal
```
## executing a signal handler
### 执行一个信号处理程序将会遇到哪些问题？？？
1. 信号处理程序是用户态进程所定义的函数，被包含在用户态代码段中。而函数 handle_signal 运行在内核态。即为了执行信号处理程序，我们需要在用户态和内核态之间进行切换

2. 当前进程恢复到正常的系统调用完成后用户的执行状态前，该进程首先需要执行信号处理程序

3. 当进程从内核态返回到用户态时，内核态堆栈就会被清空，所以内核态堆栈不再包含被中断程序的硬件上下文

4. 信号处理程序可以执行系统调用，所以当发生在信号处理程序中的系统调用返回时，它需要回到信号处理程序中，而不是被中断程序的正常代码流（可以看出这个过程中需要把各种信息记录在用户空间中）
### the solution for above problem
copying the hardware context saved in the kernel mode stack onto the user mode stack of the current process.

when the signal handler terminates, the sigreturn() system call is automatically invoked to copy the hardware context back on the kernel mode stack and to restore the original content of the user mode stack.

right before returning to user mode
```c
do_signal
    handle_signal
        setup_frame / setup_rt_frame

```

switch to user mode
```c
executing the signal handler

```
when function terminates, the return code invokes the sigreturn, the corresponding service routines copy the hardware context of the normal program to the kernel mode stack and restore the user mode stack back to its original state.
```c
returncode
    sigreturn /  rt_sigreturn
        restore_sigcontext
```


when the system call terminates, the normal program can thus resume its execution.






### How to implement the above step?
首先将内核态现场保存到进程的用户态栈帧中，然后按照子函数调用的栈帧结构在用户态堆栈中插入一个调用信号处理程序的栈帧，这样当返回到用户态时就可以开始执行信号处理程序，在信号处理程序执行完成后，再次进入内核将之前保存的被中断现场恢复回来，然后继续执行


在通过 sig_handler 的方式来 delivery signal 的时候，涉及两个关键问题，1. 如何开始执行 signal handler 2. 执行完 signal handler 之后如何恢复到原来被中断的现场继续执行

在解决这两个关键问题的过程中，主要要涉及对栈帧的修改，以及对被中断现场的保存和恢复


Ref

<https://blog.csdn.net/Longyu_wlz/article/details/109350395>
<https://gitee.com/aosp-riscv/working-group/blob/master/articles/20220816-signal-frame.md#https://gitee.com/link?target=https%3A%2F%2Fblog.csdn.net%2FLongyu_wlz%2Farticle%2Fdetails%2F109350395>
# how to config signal disposition?






