---
title: 一次时间测量引发的故事
description: time architecture
categories: [cs, knowledge, operating system, kernel]
tags: [cs, knowledge, operating system, kernel]
---
# 用户空间时间测量的精度是多少？？？
struct timespec
struct timeval

```

struct timespec {
time_t   tv_sec;        /* seconds */
long     tv_nsec;       /* nanoseconds */
};


struct timeval {
time_t      tv_sec;     /* seconds */
suseconds_t tv_usec;    /* microseconds */
};

```

# 什么是墙上时间？


# The unit of time
1 s = 10^3 ms = 10^6 us = 10 ^9 ns


# What type of time value maintained by linux system?
1. Calendar time
time_t 
2. Process time(also called CPU time)
clock_t
# What is linux Epoch?(why we need this(How to measure time))



# How many types of clock type?
two types of POSIX clocks
CLOCK_REALTIME

CLOCK_MONOTONIC


# 电子晶振是如何工作的？？（系统定时器）

# How to measure the clock time, user cpu time, and system cpu time of a process?
call system call times()
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/times.h>
#include <time.h>

static void do_cmd(char *cmd);
static void pr_times(clock_t real, struct tms *tmsstart, struct tms *tmsend);
int main(int argc, char *argv[])
{
    if (argc < 2) {
        exit(1);
    }
    char *cmd;
    cmd = argv[1];
    do_cmd(cmd);
    return 0;
}

static void
do_cmd(char *cmd)
{
    struct tms tmsstart, tmsend;
    clock_t start, end;
    int status;

    printf("\ncommand: %s\n", cmd);

    if ((start = times(&tmsstart)) == -1)
        perror("times error");

    if ((status = system(cmd)) < 0)
        perror("system() error");

    if ((end = times(&tmsend)) == -1)
        perror("times error");

    pr_times(end - start, &tmsstart, &tmsend);
    //pr_exit(status);

}

static void
pr_times(clock_t real, struct tms *tmsstart, struct tms *tmsend)
{
    static long clktck = 0;
    if (clktck == 0)
        if ((clktck = sysconf(_SC_CLK_TCK)) < 0)
            perror("sysconf error");

    printf(" real: %7.2f\n", real / (double) clktck);
    printf(" user: %7.2f\n",
            (tmsend->tms_utime - tmsstart->tms_utime) / (double) clktck);
    printf(" sys: %7.2f\n",
            (tmsend->tms_stime - tmsstart->tms_stime) / (double) clktck);
    printf(" child user: %7.2f\n",
            (tmsend->tms_cutime - tmsstart->tms_cutime) / (double) clktck);
    printf(" child sys: %7.2f\n",
            (tmsend->tms_cstime - tmsstart->tms_cstime) / (double) clktck);
}

```
ref APUE

note: the sys_times is different from the other interface



# Some system calls to user space
gettimeofday   ===> timeval
time  ===> time_t
clock_gettime  ===> timespec



                            +----------+                         +------------+
                            |  string  |                         | formatted  |
                            |          |                         |  string    |
                            +----------+                         +------------+
                                 ----                                -->
                                     \-----                     ----/    strftime
                              strptime     \------         ----/         strftime_1
                                                  \-->  --/             
                                             +-------------------+
                                             |                   |
                                             |   struct tm       |
                                             | (broken-down time)|
                                             |                   |
                                             +-------------------+
                                                  ^      |                                      
                                         gmtime   |      |  mktime                              
                                      localtime   |      v                                            
               +------------+                  +----------------+              +------------+         
               | timeval    |----------------> |  time_t        | <----------- | timespec   |         
               |            |    tv_sec        |(calendar_time) |   tv_sec     |            |         
               +------------+                  +----------------+              +------------+         
                     <-                            ^                                 -->        
                       \---                        |                             ---/           
                           \---                    |                         ---/       
                               \--                 |                    ----/           
                   gettimeofday   \---             | time           ---/     clock_gettime
                                      \--          |           ----/                    
                                         \---      |       ---/                         
                                             \---  |   ---/                             
                                                 \-|--/                                 
             --------------------------------------------------------------------------------------
                                                kernel

                                                                                                
                                                                                                
                                                                                               
                                                                                               
```c                                                                                           
#include <stdio.h>                                                                             
#include <stdlib.h>
#include <time.h>

int
main(void)
{
        time_t t;
        struct tm *tmp;
        char buf1[16];
        char buf2[64];

        time(&t);
        tmp = localtime(&t);
        if (strftime(buf1, 16, "time and date: %r, %a %b %d, %Y", tmp) == 0)
                printf("buffer length 16 is too small\n");
        else
                printf("%s\n", buf1);
        if (strftime(buf2, 64, "time and date: %r, %a %b %d, %Y", tmp) == 0)
                printf("buffer length 64 is too small\n");
        else
                printf("%s\n", buf2);
        exit(0);
}
```
ref APUE

# 内核中的两个关键角色
time
timers
# some syscalls
```c
kernel/time/time.c:62:SYSCALL_DEFINE1(time, __kernel_old_time_t __user *, tloc)
kernel/time/time.c:81:SYSCALL_DEFINE1(stime, __kernel_old_time_t __user *, tptr)
kernel/time/time.c:105:SYSCALL_DEFINE1(time32, old_time32_t __user *, tloc)
kernel/time/time.c:119:SYSCALL_DEFINE1(stime32, old_time32_t __user *, tptr)


kernel/time/time.c:140:SYSCALL_DEFINE2(gettimeofday, struct __kernel_old_timeval __user *, tv,
kernel/time/time.c:199:SYSCALL_DEFINE2(settimeofday, struct __kernel_old_timeval __user *, tv,




kernel/time/posix-timers.c:1082:SYSCALL_DEFINE2(clock_gettime, const clockid_t, which_clock,
kernel/time/posix-timers.c:1164:SYSCALL_DEFINE2(clock_gettime32, clockid_t, which_clock,
kernel/time/posix-stubs.c:93:SYSCALL_DEFINE2(clock_gettime, const clockid_t, which_clock,
kernel/time/posix-stubs.c:185:SYSCALL_DEFINE2(clock_gettime32, clockid_t, which_clock,




kernel/time/time.c:269:SYSCALL_DEFINE1(adjtimex, struct __kernel_timex __user *, txc_p)
kernel/time/time.c:349:SYSCALL_DEFINE1(adjtimex_time32, struct old_timex32 __user *, utp)



kernel/time/hrtimer.c:2118:SYSCALL_DEFINE2(nanosleep, struct __kernel_timespec __user *, rqtp,
kernel/time/hrtimer.c:2139:SYSCALL_DEFINE2(nanosleep_time32, struct old_timespec32 __user *, rqtp,
kernel/time/posix-timers.c:1245:SYSCALL_DEFINE4(clock_nanosleep, const clockid_t, which_clock, int, flags,
kernel/time/posix-timers.c:1272:SYSCALL_DEFINE4(clock_nanosleep_time32, clockid_t, which_clock, int, flags,
kernel/time/posix-stubs.c:127:SYSCALL_DEFINE4(clock_nanosleep, const clockid_t, which_clock, int, flags,
kernel/time/posix-stubs.c:220:SYSCALL_DEFINE4(clock_nanosleep_time32, clockid_t, which_clock, int, flags,



kernel/time/itimer.c:306:SYSCALL_DEFINE1(alarm, unsigned int, seconds)
kernel/time/itimer.c:113:SYSCALL_DEFINE2(getitimer, int, which, struct __kernel_old_itimerval __user *, value)
kernel/time/itimer.c:332:SYSCALL_DEFINE3(setitimer, int, which, struct __kernel_old_itimerval __user *, value,




kernel/time/posix-timers.c:577:SYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,
kernel/time/posix-timers.c:938:SYSCALL_DEFINE4(timer_settime, timer_t, timer_id, int, flags,
kernel/time/posix-timers.c:961:SYSCALL_DEFINE4(timer_settime32, timer_t, timer_id, int, flags,
kernel/time/posix-timers.c:738:SYSCALL_DEFINE2(timer_gettime, timer_t, timer_id,
kernel/time/posix-timers.c:753:SYSCALL_DEFINE2(timer_gettime32, timer_t, timer_id,
kernel/time/posix-timers.c:1004:SYSCALL_DEFINE1(timer_delete, timer_t, timer_id)


```
note:
gettimeofday and clock_gettime are implement through vdso

# How user programs get the current time and date from the kernel?
from the kernel xtime variable.
# How to update time and date in kernel for user space function correcting?
update xtime variable, the global timer interrupt handler call function update_times() 
找不到update_times，当前内核机制已经改变了？？？
init real time clock (xtime_sec, xtime_nsec)


当前已经抽象出了 tick devices，时间线的维护移动到了 tick 的处理中, update_wall_time 现在是在 tick 处理代码中调用的。

# timekeeping module
timekeeping module 维护各种timeline，向上给 timer 、用户空间的时间服务等模块提供服务，向下通过与 clocksource 和 tick 交互来维护各种 timeline。
通过 tick 可以周期性更新 time line，通过 clocksource 可以获取 tick 之间更精准的时间信息。

kernel/time/timekeeping.c


init real time clock, monotonic clock and monotonic raw clock

```c
void __init timekeeping_init(void)
{
        tk_set_xtime(tk, &wall_time);
        tk->raw_sec = 0;

        tk_set_wall_to_mono(tk, wall_to_mono);

}


```


get real time clock value
ktime_get_real 为了使得时间更精确，调用了 clocksource 的 read 函数获取 tick 之间的 delta 时间值，而 ktime_get_coarse_real 没有获取 delta 时间值，所以是一个 coarse 版本
```c
/**
 * ktime_get_real - get the real (wall-) time in ktime_t format
 */
static inline ktime_t ktime_get_real(void)
{
        return ktime_get_with_offset(TK_OFFS_REAL);
}

// 下面的函数在之前版本叫 current_kernel_time
static inline ktime_t ktime_get_coarse_real(void)
{
        return ktime_get_coarse_with_offset(TK_OFFS_REAL);
}

```


获取 monotonic clock 的方式，与上面类似

ktime_get 返回的类型是 ktime_t 
ktime_get_ts64 将值返回到 struct timespec64 类型中
## wall_to_monotonic 变量的含义
相关变量 xtime/wall_to_monotonic/jiffies


This variable is of the same type timespec as xtime, and it essentially stores the number of seconds and nanoseconds to be added to xtime in order to get a monotonic (ever increasing) flow of time. 

# how to implement sys_gettimeofday??
在 glibc 中，x86_64 的 gettimeofday 在 libc.so 中实现如下

```c
"sysdeps/unix/sysv/linux/x86/gettimeofday.c"
# ifdef SHARED
#  include <dl-vdso.h>
# include <libc-vdso.h>

static int
__gettimeofday_syscall (struct timeval *restrict tv, void *restrict tz)
{
  if (__glibc_unlikely (tz != 0))
    memset (tz, 0, sizeof *tz);
  return INLINE_SYSCALL_CALL (gettimeofday, tv, tz);
}

# undef INIT_ARCH
# define INIT_ARCH() \
  void *vdso_gettimeofday = dl_vdso_vsym (HAVE_GETTIMEOFDAY_VSYSCALL)
libc_ifunc (__gettimeofday,
            vdso_gettimeofday ? VDSO_IFUNC_RET (vdso_gettimeofday)
                              : (void *) __gettimeofday_syscall)

# else
#endif

weak_alias (__gettimeofday, gettimeofday)

```
resolve the symbol "__vdso_gettimeofday" first, if the symbol cannot be resolved, we fallback to the call of the usual system call.


gettimeofday entry is a weak alias of the __vdso_gettimeofday in kernel.
kernel 中对 __vdso_gettimeofday 的定义如下
```c
"arch/x86/entry/vdso/vclock_gettime.c"
/*
 * Fast user context implementation of clock_gettime, gettimeofday, and time.
 *
 * Copyright 2006 Andi Kleen, SUSE Labs.
 * Copyright 2019 ARM Limited
 *
 * 32 Bit compat layer by Stefani Seibold <stefani@seibold.net>
 *  sponsored by Rohde & Schwarz GmbH & Co. KG Munich/Germany
 */





int gettimeofday(struct __kernel_old_timeval *, struct timezone *)
        __attribute__((weak, alias("__vdso_gettimeofday")));


static __maybe_unused int
__cvdso_gettimeofday_data(const struct vdso_data *vd,
                          struct __kernel_old_timeval *tv, struct timezone *tz)
{

        if (likely(tv != NULL)) {
                struct __kernel_timespec ts;

                if (do_hres(&vd[CS_HRES_COARSE], CLOCK_REALTIME, &ts))
                        return gettimeofday_fallback(tv, tz);

                tv->tv_sec = ts.tv_sec;
                tv->tv_usec = (u32)ts.tv_nsec / NSEC_PER_USEC;
        }

        return 0;
}


```
调用 do_hres 来获取，如果失败，就调用 gettimeofday_fallback

```c
static __always_inline int do_hres(const struct vdso_data *vd, clockid_t clk,
                                   struct __kernel_timespec *ts)
{
}
```


```c
static __always_inline
long gettimeofday_fallback(struct __kernel_old_timeval *_tv,
                           struct timezone *_tz)
{
        long ret;

        asm("syscall" : "=a" (ret) :
            "0" (__NR_gettimeofday), "D" (_tv), "S" (_tz) : "memory");

        return ret;
}

```
via call the syscall instruction and passing the __NR_gettimeofday system call number and the given timeval and timezone.











the usual system call gettimeofday
gettimeofday 的实现就是通过调用 ktime_get_real_ts64 来获取时间
```c

SYSCALL_DEFINE2(gettimeofday, struct __kernel_old_timeval __user *, tv,
                struct timezone __user *, tz)
{
        if (likely(tv != NULL)) {
                struct timespec64 ts;

                ktime_get_real_ts64(&ts);
                if (put_user(ts.tv_sec, &tv->tv_sec) ||
                    put_user(ts.tv_nsec / 1000, &tv->tv_usec))
                        return -EFAULT;
        }
        if (unlikely(tz != NULL)) {
                if (copy_to_user(tz, &sys_tz, sizeof(sys_tz)))
                        return -EFAULT;
        }
        return 0;
}

```

# How to implement sys_clock_gettime?

vdso
```c
"arch/x86/entry/vdso/vclock_gettime.c"


"./lib/vdso/gettimeofday.c"
static __maybe_unused int
__cvdso_clock_gettime(clockid_t clock, struct __kernel_timespec *ts)
{
        return __cvdso_clock_gettime_data(__arch_get_vdso_data(), clock, ts);
}

int __vdso_clock_gettime(clockid_t clock, struct __kernel_timespec *ts)
{
        return __cvdso_clock_gettime(clock, ts);
}




int clock_gettime(clockid_t, struct __kernel_timespec *)
        __attribute__((weak, alias("__vdso_clock_gettime")));



static __maybe_unused int
__cvdso_clock_gettime_data(const struct vdso_data *vd, clockid_t clock,
                           struct __kernel_timespec *ts)
{
        int ret = __cvdso_clock_gettime_common(vd, clock, ts);

        if (unlikely(ret))
                return clock_gettime_fallback(clock, ts);
        return 0;
}



static __always_inline int
__cvdso_clock_gettime_common(const struct vdso_data *vd, clockid_t clock,
                             struct __kernel_timespec *ts)
{
        u32 msk;

        /* Check for negative values or invalid clocks */
        if (unlikely((u32) clock >= MAX_CLOCKS))
                return -1;

        /*
         * Convert the clockid to a bitmask and use it to check which
         * clocks are handled in the VDSO directly.
         */
        msk = 1U << clock;
        if (likely(msk & VDSO_HRES))
                vd = &vd[CS_HRES_COARSE];
        else if (msk & VDSO_COARSE)
                return do_coarse(&vd[CS_HRES_COARSE], clock, ts);
        else if (msk & VDSO_RAW)
                vd = &vd[CS_RAW];
        else
                return -1;

        return do_hres(vd, clock, ts);
}


```







"kernel/time/posix-timers.c"
```c
SYSCALL_DEFINE2(clock_gettime, const clockid_t, which_clock,
                struct __kernel_timespec __user *, tp)
{
        const struct k_clock *kc = clockid_to_kclock(which_clock);
        struct timespec64 kernel_tp;
        int error;

        if (!kc)
                return -EINVAL;

        error = kc->clock_get_timespec(which_clock, &kernel_tp);

        if (!error && put_timespec64(&kernel_tp, tp))
                error = -EFAULT;

        return error;
}


static const struct k_clock *clockid_to_kclock(const clockid_t id)
{
        clockid_t idx = id;

        if (id < 0) {
                return (id & CLOCKFD_MASK) == CLOCKFD ?
                        &clock_posix_dynamic : &clock_posix_cpu;
        }

        if (id >= ARRAY_SIZE(posix_clocks))
                return NULL;

        return posix_clocks[array_index_nospec(idx, ARRAY_SIZE(posix_clocks))];
}


static const struct k_clock * const posix_clocks[] = {
        [CLOCK_REALTIME]                = &clock_realtime,
        [CLOCK_MONOTONIC]               = &clock_monotonic,
        [CLOCK_PROCESS_CPUTIME_ID]      = &clock_process,
        [CLOCK_THREAD_CPUTIME_ID]       = &clock_thread,
        [CLOCK_MONOTONIC_RAW]           = &clock_monotonic_raw,
        [CLOCK_REALTIME_COARSE]         = &clock_realtime_coarse,
        [CLOCK_MONOTONIC_COARSE]        = &clock_monotonic_coarse,
        [CLOCK_BOOTTIME]                = &clock_boottime,
        [CLOCK_REALTIME_ALARM]          = &alarm_clock,
        [CLOCK_BOOTTIME_ALARM]          = &alarm_clock,
        [CLOCK_TAI]                     = &clock_tai,
};



static const struct k_clock clock_realtime = {
        .clock_getres           = posix_get_hrtimer_res,
        .clock_get_timespec     = posix_get_realtime_timespec,
        .clock_get_ktime        = posix_get_realtime_ktime,
        .clock_set              = posix_clock_realtime_set,
        .clock_adj              = posix_clock_realtime_adj,
        .nsleep                 = common_nsleep,
        .timer_create           = common_timer_create,
        .timer_set              = common_timer_set,
        .timer_get              = common_timer_get,
        .timer_del              = common_timer_del,
        .timer_rearm            = common_hrtimer_rearm,
        .timer_forward          = common_hrtimer_forward,
        .timer_remaining        = common_hrtimer_remaining,
        .timer_try_to_cancel    = common_hrtimer_try_to_cancel,
        .timer_wait_running     = common_timer_wait_running,
        .timer_arm              = common_hrtimer_arm,
};




```
so, the call to kc->clock_get_timespec in sys_clock_gettime is actually call posix_get_realtime_timespec in the CLOCK_REALTIME case.
```c
/* Get clock_realtime */
static int posix_get_realtime_timespec(clockid_t which_clock, struct timespec64 *tp)
{
        ktime_get_real_ts64(tp);
        return 0;
}

```

实际的时间获取任然是通过 timekeeper 的 ktime_get_real_ts64 函数获取的

# sys_adjtime ???

# sys_nanosleep ?
the sys_nanosleep is not located in the vDSO area like the gettimeofday and clock_gettime.

The implementation of the nanosleep will be in the help of the syscall instruction. Before call syscall instruction, the parameters must be put in processor registers according to the ABI;


```c
"sysdeps/unix/sysv/linux/x86_64/sysdep.h"
#undef INTERNAL_SYSCALL
#define INTERNAL_SYSCALL(name, err, nr, args...)                        \
        internal_syscall##nr (SYS_ify (name), err, args)
```
internal_syscall##nr function prepares arguments of system call, and then executes syscall instruction, finally returns the results.


based on hrtimer
the syscall handler in kernel
```c
"kernel/time/hrtimer.c"
SYSCALL_DEFINE2(nanosleep, struct __kernel_timespec __user *, rqtp,
                struct __kernel_timespec __user *, rmtp)
{
        struct timespec64 tu;

        if (get_timespec64(&tu, rqtp))
                return -EFAULT;

        if (!timespec64_valid(&tu))
                return -EINVAL;

        current->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;
        current->restart_block.nanosleep.rmtp = rmtp;
        return hrtimer_nanosleep(timespec64_to_ktime(tu), HRTIMER_MODE_REL,
                                 CLOCK_MONOTONIC);
}


long hrtimer_nanosleep(ktime_t rqtp, const enum hrtimer_mode mode,
                       const clockid_t clockid)
{
        struct restart_block *restart;
        struct hrtimer_sleeper t;
        int ret = 0;
        u64 slack;

        slack = current->timer_slack_ns;
        if (dl_task(current) || rt_task(current))
                slack = 0;

        hrtimer_init_sleeper_on_stack(&t, clockid, mode);
        hrtimer_set_expires_range_ns(&t.timer, rqtp, slack);
        ret = do_nanosleep(&t, mode);
        if (ret != -ERESTART_RESTARTBLOCK)
                goto out;

        /* Absolute timers do not update the rmtp value and restart: */
        if (mode == HRTIMER_MODE_ABS) {
                ret = -ERESTARTNOHAND;
                goto out;
        }

        restart = &current->restart_block;
        restart->nanosleep.clockid = t.timer.base->clockid;
        restart->nanosleep.expires = hrtimer_get_expires_tv64(&t.timer);
        set_restart_fn(restart, hrtimer_nanosleep_restart);
out:
        destroy_hrtimer_on_stack(&t.timer);
        return ret;
}




static int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)
{
        struct restart_block *restart;

        do {
                set_current_state(TASK_INTERRUPTIBLE);
                hrtimer_sleeper_start_expires(t, mode);

                if (likely(t->task))
                        freezable_schedule();

                hrtimer_cancel(&t->timer);
                mode = HRTIMER_MODE_ABS;

        } while (t->task && !signal_pending(current));

        __set_current_state(TASK_RUNNING);

        if (!t->task)
                return 0;

        restart = &current->restart_block;
        if (restart->nanosleep.type != TT_NONE) {
                ktime_t rem = hrtimer_expires_remaining(&t->timer);
                struct timespec64 rmt;

                if (rem <= 0)
                        return 0;
                rmt = ktime_to_timespec64(rem);

                return nanosleep_copyout(restart, &rmt);
        }
        return -ERESTART_RESTARTBLOCK;
}


```
hrtimer_sleeper_start_expires function starts the give high-resolution timer on the current processor. When timer will expire, then the task will be again running.
# sys_clock_nanosleep ?

clock_nanosleep

# sys_alarm ???
# sys_getitimer and sys_setitimer ???
# sys_timer_create, sys_timer_settime, sys_timer_gettime, sys_timer_delete


# how to implement sys_times???(in a different way from above)
"kernel/sys.c"
```c
static void do_sys_times(struct tms *tms)
{
        u64 tgutime, tgstime, cutime, cstime;

        thread_group_cputime_adjusted(current, &tgutime, &tgstime);
        cutime = current->signal->cutime;
        cstime = current->signal->cstime;
        tms->tms_utime = nsec_to_clock_t(tgutime);
        tms->tms_stime = nsec_to_clock_t(tgstime);
        tms->tms_cutime = nsec_to_clock_t(cutime);
        tms->tms_cstime = nsec_to_clock_t(cstime);
}

SYSCALL_DEFINE1(times, struct tms __user *, tbuf)
{
        if (tbuf) {
                struct tms tmp;

                do_sys_times(&tmp);
                if (copy_to_user(tbuf, &tmp, sizeof(struct tms)))
                        return -EFAULT;
        }
        force_successful_syscall_return();
        return (long) jiffies_64_to_clock_t(get_jiffies_64());
}

```
# 上面 sys_times 的实现是基于哪些时间相关模块实现的呢......???

# 时间子系统的内核配置有哪些选项？
CONFIG_GENERIC_CLOCKEVENTS 该选项用来选择新的通用clock source和clock event系统，否则，就是旧的时间系统（事实上在 X86_64上，默认是启用的，我还没找到在哪可以关闭？？？）
当配置了 CONFIG_GENERIC_CLOCKEVENTS 时，内核会打开 Timers subsystem 的配置选项
Timers subsystem 的内核配置主要包括 
1. tick 的配置 
（1）CONFIG_HZ_PERIODIC 启用周期性 tick, 即便是在系统 idle 时也不停止
通过下面的实现方式可以知道，周期性 tick 可以在两种模式下运行，a. 一种是本身配置为 periodic tick，b. 另一种则是通过 hrtimer 来模拟，（现在还需要确认，该配置是在上面两种实现方式下都可以运行吗？？？），c. 再补充一种，没有 hrtimer，但是 tick 运行在 one-shot 模式(这种情况是在这吗？？？我记得 one-shot 本身是在 tickless 配置下才会去切换？？？)
（2）CONFIG_NO_HZ_IDLE 该配置指在系统 idle 的时候，停掉周期性 tick
（3）CONFIG_NO_HZ_FULL

---
review problem
上面的这段配置感觉不仅仅是对 tick device 的配置，还有对 tick device 工作模式的配置，先别管具体怎么实现，我们说 periodic tick device 就用 setup_periodic_tick 来设置，而 oneshot tick device 就用 setup_oneshot_tick 来设置

---
澄清
periodic tick 能有下面的实现方式

periodic tick
periodic dyntick
sched_timer

2. hrtimer 的配置
CONFIG_HIGH_RES_TIMERS
# [Timekeeping module](#-timekeeping-module)
# 时间子系统有哪些工作模式（内核中的框架）？
1. 低精度 timer + periodic tick
clockevents_config_and_register/clockevents_register_device
tick_check_new_device
tick_setup_device
tick_setup_periodic
tick_handle_periodic(tick device <=> clock event device <=> clock event handler)

在周期 tick 中运行低精度 timer

需要注意：在该模式下任然可以使用高精度 timer，只不过其处理函数 hrtimer_run_queues 是以 tick 为周期被调用，所以相当于低精度 timer


2. 低精度 timer + dynamic tick
刚开始系统运行在 periodic tick 模式
在 timer 的软中断 run_timer_softirq 上下文中，会调用 tick_check_oneshot_change 进行是否切换到 one-shot 的检查
如果系统中有支持 one-shot 的 clock event device 那么就会发生 tick mode 的切换
在该模式下没有 hrtimer 所以调用 tick_nohz_switch_to_nohz 进行模式切换，将event handler 设置为 tick_nohz_handler 
此时，在event handler中需要调用 reprogram clock event 来产生 tick，使系统正常运行
当 cpu 运行 idle 进程时，clock event device 不再 reprogram clock event，此时系统的周期性 tick 便停了下来


3. 高精度 timer + dynamic tick
刚开始系统运行在 periodic tick 模式
在 timer 的软中断 run_timer_softirq 上下文中，会调用 tick_check_oneshot_change 进行是否切换到 one-shot 的检查
如果系统中有支持 one-shot 的 clock event device 那么就会发生 tick mode 的切换
在该模式下配置了 hrtimer 所以调用 hrtimer_switch_to_hres 将 hrtimer 从低精度模式切换到高精度模式
将 tick device 的 clock event 设备切换到 oneshot 模式，将 event handler 更新为 hrtimer_interrupt（tick_init_highres）
设定 sched timer 来模拟周期 tick ，该 hrtimer 的回调函数是 tick_sched_timer (tick_setup_sched_timer)

当系统 idle 的时候，就会 stop 这个高精度 timer 

4. 高精度 timer + periodic tick
有这种模式吗？？？

# tick device
## periodic tick
hw chip driver ==> clock event device  ==> tick_check_new_device (对于未初始化的tick device对其进行初始化，而对于已经初始化的，检查是否需要更换 clock event device的需要)

tick_setup_device   (==> tick_handle_periodic)

clock event chip dirver 会在中断处理函数中调用 clock event device 的 event handler
在周期性 tick 的场景下 clock event handler 会被设定为 tick_handle_periodic
tick_handle_periodic


   1     97  ./kernel/time/tick-common.c <<update_wall_time>>
             update_wall_time();
   2     33  ./kernel/time/tick-legacy.c <<update_wall_time>>
             update_wall_time();
   3    151  ./kernel/time/tick-sched.c <<update_wall_time>>
             update_wall_time();
   4     27  ./kernel/time/timekeeping.h <<update_wall_time>>
             extern void update_wall_time(void);



event handler:
periodic 类型的 tick device
tick_handle_periodic
(hrtimer_interrupt(有这一个吗？？？))
# one-shot tick
one-shot 类型的 tick device
hrtimer_interrupt
tick_nohz_handler



# [Timekeeping module](#-timekeeping-module)
# clocksource
"../include/linux/clocksource.h"


```c
struct clocksource {
        u64                     (*read)(struct clocksource *cs);
        u64                     mask;
        u32                     mult;
        u32                     shift;
        u64                     max_idle_ns;
        u32                     maxadj;
        u32                     uncertainty_margin;
#ifdef CONFIG_ARCH_CLOCKSOURCE_DATA
        struct arch_clocksource_data archdata;
#endif
        u64                     max_cycles;
        const char              *name;
        struct list_head        list;
        int                     rating;
        enum clocksource_ids    id;
        enum vdso_clock_mode    vdso_clock_mode;
        unsigned long           flags;

        int                     (*enable)(struct clocksource *cs);
        void                    (*disable)(struct clocksource *cs);
        void                    (*suspend)(struct clocksource *cs);
        void                    (*resume)(struct clocksource *cs);
        void                    (*mark_unstable)(struct clocksource *cs);
        void                    (*tick_stable)(struct clocksource *cs);

        /* private: */
#ifdef CONFIG_CLOCKSOURCE_WATCHDOG
        /* Watchdog related data, used by the framework */
        struct list_head        wd_list;
        u64                     cs_last;
        u64                     wd_last;
#endif
        struct module           *owner;
};
```
clocksource provide 1. API to select best available clock source in the system. 2. represent an atomic counter provided by a clocksource in human units(i.e. nanoseconds)




向下给底层 clock source chip driver 的接口
__clocksource_register
clocksource_register_hz
clocksource_register_khz

clocksource_unregister

向上给的接口
clocksource_select

timekeeping_notify
tk_clock_read



update_wall_time(timekeeper === tick)

"../include/linux/timecounter.h"



# clock events
A clock event device allows to register an event that will happen in the future.
"./time/clockevents.c"

向上的接口
clockevents_program_event
clockevents_exchange_device

向下给 clock event chip driver 的接口
clockevents_config
clockevents_register_device



if clock event device have feature flag (CLOCK_EVT_FEAT_C3STOP), it says that this clock event device will be stopped in the C3 state.


# 关于 tick devices 和 clock events 的关系
management layer 与 clock event sources 的关系
the set of system functions a clock event device will be used to support（猜测这句话中的 system functions 就是某种类型的 tick device 提供的功能）


# 几种 x86 系统上的硬件时钟
RTC
TSC
PIT
CPU Local Timer
HPET
# hrtimers
hrtimer base infrastructure <https://docs.kernel.org/timers/hrtimers.html>

include/linux/ktime.h
typedef s64     ktime_t;
ktime_t 是 hrtimer 为了实现基于 ns 单位的时间，从而与 tick 相互独立而引入的类型

## hrtimer 也需要通过 timekeeping 模块来获取时间值
ktime_get_ts
ktime_get_real_ts64

## 周期性触发的高精度 timer
tick_setup_sched_timer
tick_sched_timer
tick_sched_do_timer



hrtimer_switch_to_hres
tick_switch_to_oneshot


参考 kernel 下的 timer.c 来学习 hrtimers 实现的接口，以及使用
git log -p  kernel/hrtimer.c


# The role of clock source and clock events
To provide timekeeping for your platform, the clock source provides the basic timeline, whereas clock events shoot interrupts on certain points on this timeline, providing facilities such as high-resolution timers.


# periodic tick(draft)
periodic tick（TICKDEV_MODE_PERIODIC） 可以通过两种模式提供：
1. CLOCK_EVT_MODE_PERIODIC
2. CLOCK_EVT_MODE_ONESHOT



# how does time wheel work now?



```c
/*
 * Called by the local, per-CPU timer interrupt on SMP.
 */
static void run_local_timers(void)
{
        raise_softirq(TIMER_SOFTIRQ);
}
```
## 根据注释，这里是 smp， 那非 up 是怎么调用的？？？
```c
/*
 * Called from the timer interrupt handler to charge one tick to the current
 * process.  user_tick is 1 if the tick is user time, 0 for system.
 */
void update_process_times(int user_tick)
{
        struct task_struct *p = current;

        PRANDOM_ADD_NOISE(jiffies, user_tick, p, 0);

        /* Note: this timer irq context must be accounted for as well. */

        run_local_timers();

}


```
### periodic tick part
```c
/*
 * Periodic tick
 */
static void tick_periodic(int cpu)
{
        if (tick_do_timer_cpu == cpu) {
                raw_spin_lock(&jiffies_lock);
                write_seqcount_begin(&jiffies_seq);

                /* Keep track of the next tick event */
                tick_next_period = ktime_add_ns(tick_next_period, TICK_NSEC);

                do_timer(1);
                write_seqcount_end(&jiffies_seq);
                raw_spin_unlock(&jiffies_lock);
                update_wall_time();
        }

        update_process_times(user_mode(get_irq_regs()));
        profile_tick(CPU_PROFILING);
}



/*
 * Event handler for periodic ticks
 */
void tick_handle_periodic(struct clock_event_device *dev)
{
        int cpu = smp_processor_id();
        ktime_t next = dev->next_event;

        tick_periodic(cpu);

        if (!clockevent_state_oneshot(dev))
                return;
        for (;;) {
                /*
                 * Setup the next period for devices, which do not have
                 * periodic mode:
                 */
                next = ktime_add_ns(next, TICK_NSEC);

                if (!clockevents_program_event(dev, next, false))
                        return;
                /*
                 * Have to be careful here. If we're in oneshot mode,
                 * before we call tick_periodic() in a loop, we need
                 * to be sure we're using a real hardware clocksource.
                 * Otherwise we could get trapped in an infinite
                 * loop, as the tick_periodic() increments jiffies,
                 * which then will increment time, possibly causing
                 * the loop to trigger again and again.
                 */
                if (timekeeping_valid_for_hres())
                        tick_periodic(cpu);
        }
}


```



# 各个模式下如何完成 periodic tick 该完成的工作？
1. 通过 periodic tick 我们可以看出该完成哪些工作（并且可以和之前的 timesubsystem 做比较）
tick_handle_periodic


2. periodic dyntick (oneshot)
tick_nohz_handler


3. hrtimer_interrupt
struct tick_sched

tick_sched_timer


# 通过 tick 和 eventdevices 共同设置中断的运行过程（draw ？？？）
# 当 tick 停掉的时候，如何维护 timeline ？？？
参考下面 NO HZ 的运行

# tick broadcast functionality
kernel commit:
 f8381cba04ba8173fd5a2b8e5cd8b3290ee13a98

per cpu clock event devices can be registered as dummy devices
per cpu clock event devices can be switched from/to broadcast on demand

The broadcast function distributes the events via the broadcast function of the clock event device. (broadcast function 与别的函数有啥不同？)


replace the switch apic timer to / from IPI in power states, where the apic stops.


emulate a local clock-event device via a broadcast event source.


# tick broadcast 在 tick 停掉的过程中起到什么作用？？？
```c
asmlinkage __visible void __init __no_sanitize_address start_kernel(void)
{
        setup_arch(&command_line);
        tick_init();

```

```c
void __init tick_init(void)
{
        tick_broadcast_init();
        tick_nohz_init();
}

```


special state  - idle
在调用的过程中，如果没有任务可以执行，就去 idle
当有任务的时候，就恢复到正常执行（在什么时候去改变状态来表示有非 idle 任务可以来执行）
下面是内核中，idle 过程的实现

```c
/*
 * Generic idle loop implementation
 *
 * Called with polling cleared.
 */
static void do_idle(void)
{

        tick_nohz_idle_enter();

        while (!need_resched()) { // 下面就是执行的 ilde 过程，否则就进行调度
                arch_cpu_idle_enter();
                /*
                 * In poll mode we reenable interrupts and spin. Also if we
                 * detected in the wakeup from idle path that the tick
                 * broadcast device expired for us, we don't want to go deep
                 * idle as we know that the IPI is going to arrive right away.
                 */
                if (cpu_idle_force_poll || tick_check_broadcast_expired()) {
                        tick_nohz_idle_restart_tick();
                        cpu_idle_poll();
                } else {
                        cpuidle_idle_call();
                }


                arch_cpu_idle_exit();   
        }
        preempt_set_need_resched();
        tick_nohz_idle_exit();
        
        

}

```

方式1
一种就是周期性的去检查状态（这意味着在 idle 的 cpu 上需要有周期性去检查调度需求的过程，这种方式对 power management 是不友好的）

### 下面用两种方式来解决不友好的问题，下面两种方式对应着两个配置选项（CONFIG_NO_HZ_IDLE, CONFIG_NO_HZ_FULL）

方式2
在 idle 状态的 cpu 上，停掉周期性去检查调度需求的过程(omit scheduling-clock ticks on ilde processors)，即 periodic timer interrupts，取而代之的则是称为 on-demand interrupts 的过程，


这种状态也叫 dyntick-idle 状态，参考下面的问题。===》
当 idle task 运行的时候，它调用 tick_nohz_ilde_enter 来停掉 periodic tick，结束的时候调用 tick_nohz_idle_exit 来启动 periodic tick


方式3
在 idle 状态或只有一个可运行任务（即 busy 状态）的 cpu 上停掉 periodic scheduling tick，

## 可以看出我们在主要研究 idle processor 应该处于一种什么样的状态下面
一种就是执行 idle loop
一种是处于 sleeping state


## 如何让 idle processor 进入 sleeping state？？
linux kernel 通过 cpuidle framework 来让 idle processor 进入 sleeping state，这种状态又称为 C-states;
## 如何让进入 sleeping state （停掉 periodic timer interrupt）的 cpu wake up ???
linux kernel 通过 tick broadcast 来做这件事，具体是使用一个与 C-state 无关的 timer(这个 timer 是什么？？？) 来 wake sleeping processor

### 注意: 这里停掉的是 processor local timer

## tick broadcast device 的注册
在调用 tick_check_new_device 的时候，会调用 tick_install_broadcast_device 来检查给定的 clock event device 能不能被用来当作 broadcast device 来使用，如果可以的话就注册这个 broadcast device

kernel 使用如下的函数对 tick broadcast device 进行设置
```c
/*
 * Start the device in periodic mode
 */
static void tick_broadcast_start_periodic(struct clock_event_device *bc)
{
        if (bc)
                tick_setup_periodic(bc, 1);
}


/*
 * Setup the device for a periodic tick
 */
void tick_setup_periodic(struct clock_event_device *dev, int broadcast)
{
        tick_set_periodic_handler(dev, broadcast);

}



/*
 * Set the periodic handler depending on broadcast on/off
 */
void tick_set_periodic_handler(struct clock_event_device *dev, int broadcast)
{
        if (!broadcast)
                dev->event_handler = tick_handle_periodic;
        else
                dev->event_handler = tick_handle_periodic_broadcast;
}


```

所以，当发生 timer interrupt 的时候 tick_handler_periodic_broadcast 将会被调用

```c
/*
 * Event handler for periodic broadcast ticks
 */
static void tick_handle_periodic_broadcast(struct clock_event_device *dev)
{
        struct tick_device *td = this_cpu_ptr(&tick_cpu_device);
        bool bc_local;


        bc_local = tick_do_periodic_broadcast();



        /*
         * We run the handler of the local cpu after dropping
         * tick_broadcast_lock because the handler might deadlock when
         * trying to switch to oneshot mode.
         */
        if (bc_local)
                td->evtdev->event_handler(td->evtdev);
}


/*
 * Periodic broadcast:
 * - invoke the broadcast handlers
 */
static bool tick_do_periodic_broadcast(void)
{
        cpumask_and(tmpmask, cpu_online_mask, tick_broadcast_mask);
        return tick_do_broadcast(tmpmask);
}


```

### 再考虑一下下面的话的意思？？？
tick_do_broadcast will call the broadcast function of the given clock events which sends IPI interrupt to the set of the processors
上面描述中可以 sends IPI interrupt 的具体动作的 broadcast function 是哪个函数？？是什么时候被设置的？？（td->evtdev->broadcast（））

注意一下下面的区别：
td->evtdev->event_handler
td->evtdev->broadcast
问：上面的两个函数的具体实现是哪个？？？（在这里可以看到具体如何 sends IPI interrupt to the set of the processors）

In the end we can call the event handler of the given tick_device which actually represents interrupt handler of the local timer of a processor.
===> after this a processor will wake up.
```c
/*
 * Broadcast the event to the cpus, which are set in the mask (mangled).
 */
static bool tick_do_broadcast(struct cpumask *mask)
{
        int cpu = smp_processor_id();
        struct tick_device *td;
        bool local = false;

        /*
         * Check, if the current cpu is in the mask
         */
        if (cpumask_test_cpu(cpu, mask)) {
                struct clock_event_device *bc = tick_broadcast_device.evtdev;

                cpumask_clear_cpu(cpu, mask);
                /*
                 * We only run the local handler, if the broadcast
                 * device is not hrtimer based. Otherwise we run into
                 * a hrtimer recursion.
                 *
                 * local timer_interrupt()
                 *   local_handler()
                 *     expire_hrtimers()
                 *       bc_handler()
                 *         local_handler()
                 *           expire_hrtimers()
                 */
                local = !(bc->features & CLOCK_EVT_FEAT_HRTIMER);
        }

        if (!cpumask_empty(mask)) {
                /*
                 * It might be necessary to actually check whether the devices
                 * have different broadcast functions. For now, just use the
                 * one of the first device. This works as long as we have this
                 * misfeature only on x86 (lapic)
                 */
                td = &per_cpu(tick_cpu_device, cpumask_first(mask));
                td->evtdev->broadcast(mask);
        }
        return local;
}



```
# 为了让 idle 状态下的 cpu 进入 sleeping，需要做哪些初始化工作？？？
至少留下一个 cpu 不进入到 sleeping，用来进行 time keeping，以及通过 inter-processor interrupt 机制 wake up 其他的 cpu
tick_nohz_init


```c
void __init tick_nohz_init(void)
{
        int cpu, ret;

        if (!tick_nohz_full_running)
                return;

        /*
         * Full dynticks uses irq work to drive the tick rescheduling on safe
         * locking contexts. But then we need irq work to raise its own
         * interrupts to avoid circular dependency on the tick
         */
        // tick_nohz_full_mask store numbers of processors that have enabled full NO_HZ
        // arch_irq_work_has_interrupt checks ability to send inter-processor interrupt for the certain architecture. Because system timer of a processor will be disabled during NO_HZ mode, so we must assure there must be at least one online processor which can send inter-processor interrupt to awake offline processor.
        // In x86, it is actually checks that a processor has APIC from the CPUID:
        if (!arch_irq_work_has_interrupt()) {
                pr_warn("NO_HZ: Can't run full dynticks because arch doesn't support irq work self-IPIs\n");
                cpumask_clear(tick_nohz_full_mask);
                tick_nohz_full_running = false;
                return;
        }

        // check the current processor in the tick_nohz_full_mask. if cpumask_test_cpu return ture, we clear appropriate bit in the tick_nohz_full_mask
        if (IS_ENABLED(CONFIG_PM_SLEEP_SMP) &&
                        !IS_ENABLED(CONFIG_PM_SLEEP_SMP_NONZERO_CPU)) {
                cpu = smp_processor_id();

                if (cpumask_test_cpu(cpu, tick_nohz_full_mask)) {
                        pr_warn("NO_HZ: Clearing %d from nohz_full range "
                                "for timekeeping\n", cpu);
                        cpumask_clear_cpu(cpu, tick_nohz_full_mask);
                }
        }

        // in this place, we have know the processor that will be used for timekeeping.

        // going through all processors that are defined in the tick_nohz_full_mask, function context_tracking_cpu_set used to set the context_tracking.active percpu variable to true. kernel context tracking subsystem will ignore all context switches for the certain processor that context_tracking.active is ture.
        for_each_cpu(cpu, tick_nohz_full_mask)
                context_tracking_cpu_set(cpu);

        ret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,
                                        "kernel/nohz:predown", NULL,
                                        tick_nohz_cpu_down);
        WARN_ON(ret < 0);
        pr_info("NO_HZ: Full dynticks CPUs: %*pbl.\n",
                cpumask_pr_args(tick_nohz_full_mask));
}


```

# dyntick 是通过在 one-shot 能力的 tick 上通过 tick-sched 来实现吗？
```
79bf2bb335b85db25d27421c798595a2fa2a0e82
[PATCH] tick-management: dyntick / highres functionality

+obj-$(CONFIG_TICK_ONESHOT)                     += tick-oneshot.o
+obj-$(CONFIG_TICK_ONESHOT)                     += tick-sched.o

tick-sched ===> sched_timer
```

No idle tick implementation for low and high resolution timers("kernel/time/tick-sched.c")
# dyntick-idle 和 dyntick-periodic 之间的区别


# ref
https://lwn.net/Articles/420142/
https://tldp.org/HOWTO/Clock.html#toc2
http://www.wowotech.net/timer_subsystem/time_subsystem_index.html


重点：
https://docs.kernel.org/timers/highres.html
http://www.cs.columbia.edu/~nahum/w6998/papers/ols2006-hrtimers-slides.pdf

http://www.cs.columbia.edu/~nahum/w6998/papers/ols2006-hrtimers-slides.pdf
https://www.kernel.org/doc/ols/2005/ols2005v1-pages-227-240.pdf
https://www.kernel.org/doc/ols/2006/ols2006v1-pages-333-346.pdf

https://github.com/0xAX/linux-insides/blob/master/Timers/linux-timers-1.md
